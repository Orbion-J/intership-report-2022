\documentclass[11pt, nonacm=true, language=french, language=english]{acmart}

\input{./preambule/preambule.tex}
\usepackage{listings}

\usepackage{letltxmacro}
\newcommand*{\SavedLstInline}{}
\LetLtxMacro\SavedLstInline\lstinline
\DeclareRobustCommand*{\lstinline}{%
  \ifmmode
    \let\SavedBGroup\bgroup
    \def\bgroup{%
      \let\bgroup\SavedBGroup
      \hbox\bgroup
    }%
  \fi
  \SavedLstInline
}

\lstdefinelanguage{links}{
  morekeywords={sig,fun,case,switch,if,else,typename,effectname,do,handle,shallowhandle,lexhandle,var,fresh},
  morecomment=[l]{\#},
  commentstyle=\color{gray}
}
\lstset{
  basicstyle=\ttfamily\footnotesize,
  captionpos=b,
  numberstyle=\tiny\color{gray},
  numbers=left,
  breaklines
}
\lstset{language=links}
\lstMakeShortInline!

\setcopyright{none}

\author[R. Jourde]{Robin Jourde}
\affiliation{%
  \institution{École Normale Supérieure de Lyon}%
  \country{France}%
}
\email{Robin.Jourde@ens-lyon.fr}
\author{Supervised by Sam Lindley}
\email{Sam.Lindley@ed.ac.uk}
\author{Daniel Hillerström}
\email{Daniel.Hillerstrom@ed.ac.uk}
\affiliation{%
  \institution{The University of Edinburgh}%
  \country{United Kingdom}%
}

\renewcommand\shortauthors{Robin Jourde}


\title[M1 Internship Report]{M1 Internship Report : Effect Typing for Links}
\subtitle{2 May 2022 -- 22 July 2022, The University of Edinburgh}

\date{2 May 2022 -- 22 July 2022}

\begin{document}

\begin{abstract}
  This paper is the report of my internship at the School of Informatics of the University of Edinburgh with Sam Lindley and Daniel Hillerström from the Laboratory for Foundations of Computer Science. My intership took place from 2 May 2022 to 22 July 2022 in the Informatics Forum.
\end{abstract}


\maketitle

\vspace*{\fill}

\begin{center}
\includegraphics[width=0.5\textwidth]{logo-ens-lyon.jpeg}
\end{center}

\vspace*{\fill}

\begin{center}
\includegraphics[width=0.6\textwidth]{logo-informatics-uoe.jpg}
\end{center}

\vspace*{\fill}

\begin{center}
\includegraphics[width=0.6\textwidth]{logo-lfcs.png}
\end{center}

\vspace*{\fill}

\newpage

\tableofcontents

\newpage

\section{Introduction}

The goal of my internship was to improve the effect typing system of the Links language, allowing aliases, avoiding effect pollution and allowing polymorphic operations.

Links (section \ref{sec:links}) is an experimental tierless functional language for the web, mainly developed in the University of Edinburgh. Among its numerous features, Links supports effect handlers. Effect handlers (section \ref{sec:handlers}) are a language feature that is becoming more and more widespread. They allow the user to define and compose many functionalities from exceptions to concurrency and probabilistic programming. My work (section \ref{sec:contribution}) focused on the typing system (section \ref{sec:typing}), especially dedicated to these handlers.


\section{Links}
\label{sec:links}

\begin{fquote}[Links website \cite{links-org}]
 Links is a functional programming language designed to make web programming easier.
\end{fquote}

Links \citep{links} is a tierless functional programming language for the web developed at the University of Edinburgh. Typical web development involves the manipulation of several \emph{tiers} which means several, sometimes really different, programming languages :
\begin{itemize}
  \item the server side written in Python or Java for instance
  \item the client side in JavaScript and HTML/CSS
  \item the database queries in SQL
\end{itemize}
This is neither elegant nor really practical and prevents easy binding between different parts of the program that need to exchange data. It can cause \emph{impedance mismatch}, ie situations where the objects required by the server do not match what the database provides and vice versa.

Links avoids these by providing the programmer one single language for all tiers (HTML/CSS are still needed) that is compiled into bytecode for the server, JavaScript for the client and SQL for the queries.

Links also supports numerous useful features including
\begin{itemize}
  \item polymorphic variants
  \item regular expressions
  \item session types
  \item row typing
  \item effect handlers (see \ref{sec:handlers})
\end{itemize}
It is used as an experimental language by researchers to try out new ideas and what could be future widespread programming languages features.

Links is strict, statically typed and use a Hindley-Milner type system as well as a Rémy style row typing system \ref{sec:row-typ} \citep{row-typ}. Its syntax is inspired from JavaScript and ML. Its compiler \citep{gh:links} is written in OCaml.

\begin{rem}
  In appendix \ref{sec:tech}, the reader could find some technical points on Links syntax and semantics that are not worth developing here. They are invited to look at it whenever needed.
\end{rem}

\section{Effect handlers}
\label{sec:handlers}

In functional programming, functions are seen as black boxes that takes an input and computes an output. Though this view of \emph{pure} functions is convenient and pleases $\lambda$-calculus fans, it fails to accurately represent what real programming is. Computations interact with the outer world by many means :
\begin{itemize}
  \item input/output
  \item concurrency
  \item exceptions
  \item choice and non determinism
  \item ...
\end{itemize}
The ``outer world'' here stand for anything that is not the pure computation, from memory, other threads and user interaction to the evaluation context itself.
These interactions not taken into account by the black-box model are called \emph{effects}.

Gordon Plotkin and Matija Pretnar \citep{plotkin-pretnar} introduced a construct that allow \emph{composable} and \emph{customisable} user-defined interpretation of effects : \emph{effect handlers}. They give the programmer direct access to the context, in the form of a first class continuation, often called \emph{resumption}.

Effect handlers can be seen as a generalisation of exception handlers. One can perform an effect in the same way as one could raise an exception and this will transfer the flow control to a handler. It is given the delimited continuation between the point where the effect is performed and where it is handled and can use it
\begin{description}
  \item[0 time] and act as an exception handler
  \item[once] (linear handler)
  \item[twice or more] (non-linear handler) to simulate a choice for instance
\end{description}

Effect handlers are being shown a growing industrial interest nowadays. Below are listed some of the biggest projects that uses and implement some kind of effect handlers
\begin{itemize}
  \item GitHub code analysis library Semantic (used in more than 25 million repositories)
  \item Meta JavaScript UI library React (used in more than 2 million websites)
  \item Uber Pyro language (Poutine library) \cite{pyro, pyro-poutine}
  \item WebAssembly \cite{wasmfx}
\end{itemize}

\subsection{Syntax and usage}

We give the Links syntax alongside with usage of effect handlers and operations. All examples in this report are written in Links.

Inside any segment of code, one can invoke an operation !Op! with payload !p! writing !do Op(p)!. This has to be scoped into a handler of this operation. It will take the payload and the resumption and decide what to do.

\begin{lstlisting}[caption=Handler,label=lst:handler]
  handle ( code ) {
    case <Op(p) => r> -> ...
    case x -> ...
  }
\end{lstlisting}

Listing \ref{lst:handler} give the syntax for a handler for !Op!, !code! being the code that can perform the operation. When the operation is invoked, the right hand side of line 2 is executed with !p! the payload and !r! the resumption bound in context. When !code! returns a value, line 3 is executed with !x! bound to that value.

If the handler gives the resumption a value !v!, it acts as if !do Op(p)! returned the value !v!. If the payload has type !t! and !v! has type !t'!, we say that !Op! has type !t => t'!.

The type system keeps track of what effects can be performed. A function from type !a! to !b! which can performs operations !Op1: t1 => t1'!, \dots, !Opk:tk => tk'! will have type !(a) {Op1:t1 => t1', ..., Opk:tk => tk'}-> b!.


\subsection{Examples}

\begin{ex}[A first exception handler] \

\begin{lstlisting}[caption=Fail invocation]
  sig assert_positive : (Int) {Fail:() => Zero|_}-> Int
  fun assert_positive(x) {
    if (x>0) x else absurd(do Fail)
  }
\end{lstlisting}

This first example shows a function !assert_positive! that takes an integer and returns it only if it positive, else, it raises the effect !Fail! (for details on !absurd! and the !Zero! type, see \ref{sec:tech:zero}). This is the simplest example when one operation is invoked with no payload.

\begin{lstlisting}[caption=maybe handler, label=lst:mb-h]
  sig maybe : (() {Fail:() => Zero|e}~> a) -> () {Fail{_}|e}~> Maybe(a)
  fun maybe (m) () {
    handle (m()) {
      case <Fail> -> Nothing
      case x -> Just(x)
    }
  }
\end{lstlisting}

This operation can be handled by the !maybe! handler presented in listing \ref{lst:mb-h}. This is actually an exception handler since the resumption is not used in the right hand side (and thus can be omitted in the left hand side). The \emph{effect signature} is !{Fail: () => Zero}!, that means there is only one operation called !Fail! that will be handled.

When the operation !Fail! is invoked, the handler directly returns a value, here !Nothing!. When the computation returns a value, the handler will return that value, embedded in the !Maybe! type (on !Maybe! type, see \ref{sec:tech:maybe}).

The function !maybe! will take a computation that can perform the effect !{Fail: () => Zero|e}! ie the operation !Fail! and possibly other effects captured by the row variable !e! and will return something of type !a!. It will execute this computation, performing effects from !e! that should be handled by another handler at some point. In the end, it returns a value of type !Maybe(a)!.

The !Fail{_}! in the effect row indicates a polymorphic presence for the operation. Roughly it means that the operation can or cannot be present after. This is needed since the effect type system enforces that all operations in a row are distinct. !Fail! cannot belong to !e! because of the effect row of the input computation. See section \ref{sec:links-typ} for more details on presence.

\begin{lstlisting}
  sig h2g2 : () {Fail:() => Zero|_}-> Int
  fun h2g2 () {
    assert_positive( -6 * -7 )
  }
  sig h2g2' : () {Fail:() => Zero|_}-> Int
  fun h2g2' () {
    assert_positive( -6 ) * -7
  }
\end{lstlisting}

We can then use the !maybe! function to handle the failures in functions !h2g2! and !h2g2'! :

\begin{lstlisting}[caption=Links console]
  links> maybe ( h2g2 ) () ;
  Just(42) : Maybe (Int)
  links> maybe ( h2g2' ) () ;
  Nothing : Maybe (Int)
\end{lstlisting}

\end{ex}

\begin{ex}[Drunk coin tossing]

We consider now a new operation !Choose! that can produce a boolean and use it to simulate a drunk coin toss. A drunk tosses a coin and either let it fall or catch it and see heads or tail.

\begin{lstlisting}[caption=Drunk toss]
  typename Toss = [| Heads | Tail |] ;

  sig toss : () {Choose:Bool|_}-> Toss
  fun toss () {
    if (do Choose) Heads else Tail
  }

  sig drunkToss : () {Choose:Bool, Fail:Zero|_}-> Toss
  fun drunkToss () {
    if (do Choose)
      # catch
      toss ()
    else
      # fall
      absurd(do Fail)
  }

  sig drunkTosses : (Int) -> Comp([Toss], {Choose:Bool, Fail:Zero|_})
  fun drunkTosses (n) () {
    if (n<=0)
      []
    else
      drunkToss() :: drunkTosses (n-1) ()
  }
\end{lstlisting}

We can define several handlers for this operation.

\begin{lstlisting}[caption=Toss handlers]
  # linear handler : always true
  sig h_true : (Comp(a,{Choose:Bool|e})) -> Comp(a,{Choose{_}|e})
  fun h_true (m) () {
    handle (m()) {
        case <Choose => r> -> r(true)
    }
  }

  # non-linear handler : all choices in a list
  sig h_all : (Comp(a,{Choose:Bool|e})) -> Comp([a],{Choose{_}|e})
  fun h_all (m) () {
    handle (m()) {
        case <Choose => r> -> r(true) ++ r(false)
        case x -> [x]
    }
  }
\end{lstlisting}

And then we can compose the different handlers in several ways.

\begin{lstlisting}
  links> maybe ( h_true ( drunkTosses(2) ) ) () ;
  Just([Heads, Heads]) : Maybe ([Toss])
  links> h_true ( maybe ( drunkTosses(2) ) ) () ;
  Just([Heads, Heads]) : Maybe ([Toss])

  links> maybe ( h_all ( drunkTosses(2) ) ) () ;
  Nothing : Maybe ([[Toss]])
  links> h_all ( maybe ( drunkTosses(2) ) ) () ;
  [Just([Heads, Heads]), Just([Heads, Tail]), Nothing, Just([Tail, Heads]), Just([Tail, Tail]), Nothing, Nothing] : [Maybe ([Toss])]
\end{lstlisting}

We try different combinations for 2 coin tosses. In the two first cases, there is no failure so the order of handlers won't matter. The coin is always catch and always on heads.

In the third case, !h_all! imposes that all possibilities are explored so at some point, the coin will fall. This causes a failure, catch by !maybe! that simply returns !Nothing!.

The last case is the most complicated one. The failures are catch by !maybe! \emph{under} !h_all!. That means !h_all! won't see failures and will take each result, whether it is a !Nothing! or a list of heads/tail and form its big list of all possibilities.

\end{ex}

\subsection{Semantics}
\label{sec:semantics}

We give the operational semantics for handlers.
\[
  \begin{array}{rcl}
    !handle ( !v! ) { !H! }! & \longrightarrow & N[v/!x!] \\
    !handle ( !\mathcal E[!do !Op_{i}!( !v! )!]! ) { !H! }! & \longrightarrow & N_{i}[v/!p!, !fun (x)  { handle ( !\mathcal E[!x!] ! ) { !H! } }!/!r!] \\
                                                                             && Op_{i} \notin \mathcal E\\
  \end{array}
\]

where $H =
\left\{\begin{array}{l}
  !case x! \mapsto N \\
  !case ! \langle Op_{i}(!p!) \To !r!\rangle \mapsto N_{i} \\
  \dots \\
\end{array}\right.$

and $\mathcal E$ is an evaluation context : $\mathcal E ::= [] \mid !handle ( !\mathcal E! ) { !H! } ! \mid !var x = ! \mathcal E ! ; ! N$.

$Op \in \mathcal E$ means there is a handler for $Op$ in $\mathcal E$.

If there is a value $v$ inside the handler, we call the return case $N$ with !x! bound to $v$. When the handler is the most inner one that can handle the operation $Op_{i}$ invoked with some payload $v$, what is insured by $Op_{i}\notin \mathcal E$, we bind the payload and build the resumption before calling the case $N_{i}$.

The resumption is embedded in the current handler since operation $Op_{i}$ could be invoked in the rest of the evaluation context $\mathcal E$. This is called a \emph{deep} handler.

\paragraph{Shallow handlers}
Links also support \emph{shallow} handlers, ie handlers that do not automatically reuse the handler in the resumption. The programmer has to write it and can choose another handler if needed. Below is the new rule for shallow handler.
\[
  \begin{array}{rcll}
    !shallowhandle ( !\mathcal E[!do !Op_{i}!( !v! )!]! ) { !H! }! & \longrightarrow & N_{i}[v/!p!, !fun (x)  { ! E[!x!] ! }!/!r!] & Op_{i} \notin \mathcal E\\
  \end{array}
\]

\paragraph{Parameterised handlers}

Another useful feature of handlers is that they could be parameterised. The programmer can give the handler a parameter that is carried along the computation.

\begin{lstlisting}[caption=Example of parameterised handler for a state effect]
  sig h_state : (a) -> (Comp(b,{ Get:()=>a, Put:(a)=>() | e })) ~> Comp((b,a), { Get{_}, Put{_} | e })
  fun h_state (init) (m) () {
    handle (m()) (s <- init) {
      case x -> (x, s)
      case <Get => r> -> r (s, s)
      case <Put(s') => r> -> r ((), s')
    }
  }
\end{lstlisting}

\begin{lstlisting}
  fun ex () {
    var x = do Get * 10 ;
    var x = 2*x + do Get ;
    do Put(x) ;
    ()
  }

  links> h_state (2) (ex) () ;
  ((), 42) : ((), Int)
\end{lstlisting}

A second parameter is given to the !handle! construct that binds a variable and the resumption will take an additional parameter.

In the example above, we use that feature to write a state-cell handler. There are two operations !Put! and !Get! that respectively write into the cell and read what is inside. The parameter here is just the content of the cell.

Here are the reduction rules for parameterised handlers
\[
  \begin{array}{rcll}
    !handle ( !v! ) ( s!\from w! ) { !H! }! & \longrightarrow & N[v/!x!, w/!s!] \\
    !handle ( !\mathcal E[!do !Op_{i}!( !v! )!]! ) !  & \longrightarrow & N_{i}[v/!p!, w/!s!, \\
    ! ( s!\from w! ) { !H! }!                        &                 & !fun (x, s')  { handle ( !\mathcal E[!x!] ! ) ( s!\from!s' ) { !H! } }!/!r!] \\
                                                     &                 & Op_{i} \notin \mathcal E\\
  \end{array}
\]

\begin{rem}
  A parameterised handler has to be deep since the parameter needs a handler to carry it.
\end{rem}

\paragraph{Relationships between handlers}

Those three kinds of handlers are equivalent in the sense that it is possible to express each of them using one other.

If it is easy to see how to express a deep handler from a parameterised handler or from a shallow handler, the converse is not so obvious. In \citep{ehgc}, section 4 or \citep{daniel-thesis}, section 6 are presented some ways of doing that.

\section{Typing}
\label{sec:typing}

Links is a strongly statically typed language. In this section, we describe some main features of the Links type system that allow us to type effect handlers.

\subsection{Rows}
\label{sec:row-typ}

In order to type effects, we store in function types the effects that are \emph{allowed} to be performed during the execution of that function. To do so we use rows, an unordered and labeled data and type structure. They are also used in others features of Links such as records and variants.

In the most general setting, a row is defined by
\[
  R ::= \bullet \mid \rho \mid l:\delta;R
\]
where $\rho$ is a row variable, $l$ is a label and $\delta$ is a data. $\bullet$ denotes the empty row.

A row is said to be \emph{open} if it ends with a row variable and \emph{closed} if it ends with the empty row.

For concrete records, the data are actual values of the language but in the typing setting (typing effects, records and variants), $\delta$ will be a presence (see \ref{sec:links-typ}).

We require also that in one row, labels are all distinct and we consider rows equal up to reordering of pairs labels/data.

\begin{ex}
  $Fail:Zero; Choose:Bool; \bullet$ is a valid row and is equal to $Choose:Bool; Fail:Zero; \bullet$ but $Fail:Zero; Fail:Int; R$ and $Fail:Zero; Fail:Zero; R$ are not valid. In the open row $Choose:Bool; R$, $R$ could not be substituted by anything with label $Choose$.
\end{ex}


\subsection{Links type system}
\label{sec:links-typ}

We describe in this section and the following Links type system. In order to avoid useless complexity, we focus on the parts of the type system that are useful to understand effect typing. We omit easy and common parts as well as some parts used only for other Links features.

Below is the type and kind syntax.

\[
  \begin{array}{lrrll}
    \text{Kinds}           & K & ::= & Type \mid Row \mid Presence & \\
                           &&\mid & \kappa & \text{kind variable} \\

    \text{Rows}            & R, E & ::= & \bullet & \\
                           &&\mid & l:P;R & \\
                           &&\mid & \rho & \text{row variable} \\

    \text{Presence}        & P & ::= & - & \text{absent} \\
                           &&\mid & T & \text{present with a type} \\
                           &&\mid & \theta & \text{presence variable} \\

    \text{Types}           & T, A, B & ::=\ & P & \text{primitive type} \\
                           &&\mid & T \to_{E} T & \text{function type} \\
                           &&\mid & T \To T & \text{operation type} \\
                           &&\mid & (R) & \text{record type} \\
                           &&\mid & [R] & \text{variant type} \\
                           &&\mid & \forall \alpha :: K. T & \text{polymorphic type} \\
                           &&\mid & A\ B & \text{type application} \\
                           &&\mid & \alpha & \text{type variable} \\

    \text{Primitive types} & P & ::= & Int \mid Bool \mid String \mid \dots &
  \end{array}
\]

We have three different kinds that are usual \emph{types}, \emph{rows} and \emph{presence types}.

Any label that appears into a row is associated with a presence type that indicates if the label is present in this row. If it is, we have to provide a type, otherwise this is not necessary and we just indicate the absence. One may wonder why are presence useful. After all, to know if a label is present in a row, looking at the row should be enough. This is true for closed rows but not for open ones. Writing $l:-;\rho$ implies that the row variable $\rho$ cannot stands for a row containing $l$ since a label cannot appear twice in a row. Absence guarantees that whatever the row variable is substituted with, this label will never occur.

\begin{rem}
  In \emph{closed} rows, absence is redundant :
  $$ l_{0}:- ; l_{1}:P_{1} ; \dots ; l_{k}:P_{k} ; \bullet = l_{1}:P_{1} ; \dots ; l_{k} : P_{k} ; \bullet $$
\end{rem}

\paragraph{Links syntax for presence and effect rows}
In Links, we write effect rows between braces !{ ... }!. For a label !A!, the absence is denoted !A-!, the typed presence !A:type! and the polymorphic presence !A{p}!, with !p! a variable of presence kind. The empty row is denoted by !{}!, the closed row $l_{1}:\delta_{1}; \dots; l_{k}:\delta_{k}$ is denoted by !{l1:d1, ..., lk:dk}! and the open row $l_{1}:\delta_{1}; \dots; l_{k}:\delta_{k}; e$ is denoted by !{l1:d1, ..., lk:dk | e}!.

\subsection{Typing handlers}
\label{sec:typing-handlers}

The typing judgement has to take into account the current allowed effects. We gather them into a row $R$ and we write $\Delta;\Gamma \vdash e : T / R$ for expression $e$ has type $T$ in context $\Delta;\Gamma$ and can perform effects in $R$.

\begin{rem}
  The context contains two parts $\Gamma$ and $\Delta$. $\Gamma = x : A ; \dots$ contains typed term variables and $\Delta = \alpha :: K; \dots$ kinded type variables.
\end{rem}

We give below the main typing rules that allow us to understand how effect handlers should be typed. The other rules are the obvious ones and are not mentioned. For the sake of clarity, shallow and parameterised handlers rules have also been moved to the appendix \ref{sec:typing-rules}.

\begin{table}[h!]
  \centering
  \begin{tabular}{ccc}
    \AxiomC{$\Delta;\Gamma, x:B \vdash e : A / R$}
    \RightLabel{$Fun$}
    \UnaryInfC{$\Delta;\Gamma \vdash fun (x) \{ e \} : B \to_{R} A / R$}
    \DisplayProof
    &
      \AxiomC{$\Delta;\Gamma \vdash f : B \to_{R} A / R$}
      \AxiomC{$\Delta;\Gamma \vdash t : B / R$}
      \RightLabel{$App$}
      \BinaryInfC{$\Delta;\Gamma \vdash f t : A / R$}
      \DisplayProof
    \\
  \end{tabular}
\end{table}

\begin{prooftree}
  \AxiomC{$\Delta;\Gamma \vdash p : B / R$}
  \AxiomC{$R = l : B \To A ; R'$}
  \RightLabel{$Op$}
  \BinaryInfC{$\Delta;\Gamma \vdash do\ l(p) : A / R$}
\end{prooftree}

\begin{prooftree}
  \AxiomC{$\Delta;\Gamma \vdash m : B / R'$}
  \AxiomC{$\Delta;\Gamma, x:B \vdash n : A / R$}
  \AxiomC{$R' = (l_{i} : B_{i} \To A_{i})_{i} ; R_{0}$}
  \AxiomC{$R = (l_{i} : P_{i})_{i} ; R_{0}$}
  \noLine
  \BinaryInfC{$\forall i,\; \Delta;\Gamma, p_{i}:B_{i}, r_{i}:A_{i} \to_{R} A \vdash n_{i} : A / R$}
  \RightLabel{$Handle$}
  \TrinaryInfC{$\Delta;\Gamma \vdash handle (m) \{ case\ x \mapsto n\; (case \langle l_{i} (p_{i}) \To r_{i} \rangle \mapsto n_{i})_{i}\} : A / R$}
\end{prooftree}


Rule $Op$ states that invoking an operation requires a ambient effect row that contains it with the correct types. Rule $App$ ensures that, when applying a function, its effect row is compatible with the ambient one. The $Handle$ rule types a !handle! construct. The important thing to notice is that the row used to type $m$ obviously contains the operations $l_{i}$ handled and that after handling, all $l_{i}$s have been removed from the row.

\begin{rem}
  The following rule $WeakEff$ is admissible from the other rules. It ensures that the ambient effect row mentions effects that are \emph{allowed} to be performed but not necessary since an effect can be added to the row.
  \begin{prooftree}
    \AxiomC{$\Delta;\Gamma \vdash e : A / R$}
    \AxiomC{$R \subseteq R'$}
    \RightLabel{$WeakEff$}
    \BinaryInfC{$\Delta;\Gamma \vdash e : A / R'$}
  \end{prooftree}
  where $R \subseteq R'$ is defined by
  \begin{table}[h!]
    \centering
    \begin{tabular}{ccccc}
      \AxiomC{}
      \UnaryInfC{$R \subseteq R$}
      \DisplayProof
      &
        \AxiomC{}
        \UnaryInfC{$R \subseteq \rho$}
        \DisplayProof
      &
        \AxiomC{$R \subseteq R'$}
        \UnaryInfC{$R \subseteq l:P;R'$}
        \DisplayProof
      &
        \AxiomC{$R \subseteq R'$}
        \UnaryInfC{$l:P;R \subseteq l:P;R'$}
        \DisplayProof
      &
        \AxiomC{$R \subseteq R'$}
        \UnaryInfC{$l:\theta;R \subseteq l:P;R'$}
        \DisplayProof
    \end{tabular}
  \end{table}
\end{rem}

We say that an expression $e$ type-checks only if no unhandled effects are allowed : $\Delta;\Gamma \vdash e : T / \bullet$, noted $\Delta;\Gamma \vdash e : T$.


\begin{thm}
  If $\Delta;\Gamma \vdash e : T / R$, in the execution of $e$ only effects in $R$ are performed and not handled.
\end{thm}
\begin{cor}
  If $\Delta;\Gamma \vdash e : T$, in the execution of $e$ all effects are handled.
\end{cor}

See \citep{links-effect} for the proof.


\subsection{Polymorphism}

Links supports a System F \cite{proof-type-girard} style polymorphism. Types can contain kinded variables $\alpha$ that can be abstracted over with a $\forall \alpha :: K$. A polymorphic type can be instantiated with a type application.

For more details on Links polymorphism, one could look at \cite{polymorph-rpc-links}.


\section{Contributions}
\label{sec:contribution}

During my internship I added some new features that have been or will soon be merged into Links.

\subsection{Effect aliases}

In Links we can define type aliases using the keyword !typename!.
\begin{lstlisting}[caption=Type alias examples]
  # sum type via variants
  typename BinTree(a) = [| Node(BinTree(a), a, BinTree(a)) | Leaf |] ;
  # product type
  typename IntPair = (Int, Int) ;
  # record type
  typename Pet = (name:String, age:Int, species:String, Fur:Bool) ;
  # function type
  typename Comp(a, e::Row) = () ~e~> a ;
\end{lstlisting}

But until now, there was no way to define such thing for effects. This is really useful since when working with effects, the same set of effects shows up everywhere.

Using the new keyword !effectname! we can now write an alias for an effect row :
\begin{lstlisting}
  effectname MyEffectRow(a, ... ,e::Eff, ...) = { Op1 : type, ... | e } ; # open row
  effectname MyEffectRow(a, ... ) = { Op1 : type, ... } ; # closed row
\end{lstlisting}

To use it in a signature or in another type or effect alias just apply it with the right arguments as for typename things. In arrows, it can be used as row variables:
\begin{lstlisting}
  () -MyEffectRow(args)-> ()
\end{lstlisting}

However, due to lack of kind inference, row variables and aliases have to be used carefully so that Links does not think they are of kind type. We need to write them most of the time between braces !{ | ... }!. For instance, if there is !effectname E(a::Eff) = {X : ... | a }! and a row variable !e::Eff!, you will have to write !E({ |e})!, and similarly for another effect alias instead of the variable. This makes the usage of several nested aliases a bit messy, it would be nice if it could be avoided.

Recursive effect aliases are not available for now. The aliases are replaced by the row they correspond to. Aliases are not kept and thus cannot be printed out.

The implementation is mostly inspired by what is done for type aliases.

\subsection{Fresh labels}
\label{sec:fresh-labels}

\subsubsection{The pollution problem}
\label{sec:pollution-problem}

We first introduce a problem that arises when playing with numerous effects and that we will be calling \emph{effect pollution}. Let us start with an example.

\begin{lstlisting}
  sig receives : ([Int]) -> ( Comp(a, {Fail:Zero, Receive:Int |e}) ) -> Comp(a , {Fail:Zero, Receive{_}|e})
  fun receives (ss) (h) () {
    handle (h()) (ss<-ss) {
      case <Receive => r> -> switch (ss) {
        case [] -> absurd(do Fail)
        case h::t -> r (h,t)
      }
      case x -> x
    }
  }
\end{lstlisting}

Let !receives! be a (parameterised) handler for the operation !Receive! that provides an integer. This handler will read the integers from a list that it has been given. When the end of the list is reached, an error is raised.

\begin{lstlisting}
  fun not_too_big () {
    var x = do Receive ;
    if (x >= 42)
       absurd(do Fail)
    else x
  }

  typename Sized(a) = (val:Maybe(a), big:Bool) ;

  sig solve_too_big : ( Comp(a, {Fail:Zero |e}) ) -> Comp(Sized(a), {Fail{_}|e})
  fun solve_too_big (h) () {
    handle (h()) {
      case <Fail> -> (val=Nothing, big=true)
      case x      -> (val=Just(x), big=false)
    }
  }
\end{lstlisting}

Let us imagine another piece of code that uses this effect !Receive! but does not want too big numbers. When something too big is given, a failure is raised and then catch by a handler that will keep track of it.

What happen if we want to have these to work together ?

\begin{lstlisting}
  fun two () { not_too_big () + not_too_big () }

  links> solve_too_big( maybe( receives ([21,21,21]) ( two ))) () ;
  (big = false, val = Just(Just(42))) : Sized (Maybe (Int))

  links> solve_too_big( maybe( receives ([42,42,42]) ( two ))) () ;
  (big = false, val = Just(Nothing)) : Sized (Maybe (Int))
\end{lstlisting}

If we compose handlers the way above, we see that 42 is too big but the !big! value is set to false. The !Fail! raised by !not_too_big! has been catch by !maybe!. The shared !Fail! effects interfere and are mixed up. This is what we call \emph{effect pollution}.

That kind of effect pollution could become really annoying when one works with a large amount of code and numerous effects and handlers. It also reduces modularity.

\subsubsection{State of the art}
\label{sec:state-art}

Until then, we could find two constructions that tackle this issue in the literature : \emph{lexically scoped handlers} and \emph{effect coercions}.

\paragraph{Effect coercions}
Effect coercions, also known as \emph{adaptators} (\citep{doobeedoo} section 3), are constructions that change how operations are interpreted and handled.

The simplest example is the \emph{lift} or \emph{mask} coercion that masks the operation from the nearest handler. A masked operation is then handled by the second nearest handler.

Coercions could also be exchanges, also called \emph{swap}, or effect duplication in some contexts.

It turns out that, if they offer a solution to the pollution problem, they are not so practical. Moreover they seems a bit \emph{ad hoc} and are not really satisfying.

\paragraph{Lexically scoped handlers}
\cite{lex-eff} introduces this kind of handlers where one can figure out statically which handler is invoked when. This is achieved by not having operations but computations that take an operation function as parameter.
\begin{lstlisting}
  lexhandle ( fun (op) { e } ) with { case <p => r> -> ... }
\end{lstlisting}
\begin{rem}
  In this setting, the handler does not handle ``by name''. That's why it does only need the payload and not the label of the operation in !case <p => r>!.
\end{rem}

Biernacki et al. \cite{binders-labels} use another version of lexically scoped effects with names. Handlers and operations labels are coupled with names that binds them together. Handlers act as binders for theses names.

\subsubsection{A fresh idea ?}
\label{sec:fresh-idea}

In \cite{tes}, de Vilhena and Pottier develop the idea of lexically scoped handlers and propose, as we do, to use fresh effect label generation. Our work has be done in parallel but it turns out that they formalised a system close to what we use and describe there.

Our system has two sort of labels, noted $l$ :
\begin{description}
  \item[global labels] labels as previously used, defined uniquely by their name
  \item[local labels] labels that are restricted to a scope and are identified by their name together with an identifier $id \in \N \cup \{\bot\}$
\end{description}
$$ l ::= Op \mid `Op^{\langle id\rangle} $$
To distinguish local and global labels we use a backtick for local ones. The programmer does not need to find by themselves the identifier. They do not specify any (which is represented by the ``free'' identifier $\bot$) and fresh unique identifiers are created automatically.

We define a new construct !fresh `A { e }!  where !e! is any list of function and/or aliases definitions. This is a binding for local labels. When this is encountered a new unique identifier is generated for !`A! and each local occurrence of !`A! in the scope !e! is bound to this identifier.
\begin{rem}
  When several !fresh! bindings with the same name are nested, a label is bound by the innermost !fresh!.
\end{rem}

\paragraph{Going out of scope}
A function, value or alias that has a local label in its type cannot escape the scope, but we do want to keep some of the declarations made in that scope. When leaving the scope, for each declaration, we try to \emph{erase} the fresh label $l$ from its type. If it is possible, ie if the label has a polymorphic or absent presence, the function/value/alias declared is added into the context and is available in the rest of the program, its type being cleaned from any local label. Otherwise, the function/value/alias is removed from the context.

We write $A \uparrow_{l} A'$ if one can erase label $l$ from type $A$ and this will give type $A'$, and $A \downarrow_{l}$ if it is not possible to erase label $l$ from type $A$, ie if there exists no $A'$ such that $A \uparrow_{l} A'$. Below are the most interesting rules that define the erasure of a row type. The rest of the rules can be found in appendix \ref{sec:erasing-procedure}.

\begin{table}[h!]
  \centering
  \begin{tabular}{cccc}
    \AxiomC{$R\uparrow_{l}R'$}
    \UnaryInfC{$l:-;R\uparrow_{l}R'$}
    \DisplayProof
    &
      \AxiomC{$R\uparrow_{l}R'$}
      \UnaryInfC{$l:\theta;R\uparrow_{l}R'$}
      \DisplayProof
    &
      \AxiomC{$T\uparrow_{l}T'$}
      \AxiomC{$R\uparrow_{l}R'$}
      \AxiomC{$l\neq l'$}
      \TrinaryInfC{$l':T;R \uparrow_{l} l':T' ; R'$}
      \DisplayProof
    &
      \AxiomC{}
      \UnaryInfC{$l:T;R \downarrow_{l}$}
      \DisplayProof
  \end{tabular}
\end{table}

The two first rules state that absent or polymorphic instances of the label can be erased, the third one shows how the erasure propagates into the row and the last one forces the erasure of a present instance to fail.

\begin{thm}
  For any label $l$ and type $T$, exactly one of the following holds
  \begin{itemize}
    \item either there exists a unique $T'$ such that $T\uparrow_{l}T'$. We write $e(T) = T'$
    \item or $T\downarrow_{l}$
  \end{itemize}
\end{thm}

The proof is by induction on types.

At the end of the scope, for each declaration, we type it and get its type $T$. If $e(T)$ exists, we replace its type by $e(T)$ in the context. Otherwise, we remove the object from the context.
Thus, local labels cannot escape.

\subsubsection{Implementation and usage in Links}
\label{sec:impl-usage-links}

The possibility to define local labels, ie labels that can only be used in a specific scope, has been added to Links.

The user can define one or more local labels that will be bound in the scope with
\begin{lstlisting}
  fresh `A, `B {
    [ scope where labels `A and `B are bound ]
  }
\end{lstlisting}

He can use the local labels so defined in the scope as any other effect label but he cannot use them outside that scope.

\paragraph{Solving pollution}
This can be used to solve pollution issues by shadowing effects that would interfere with a local name.

\begin{lstlisting}[caption=Using local effects to avoid pollution]
  fresh `Fail {

    sig protect : (Comp(a, {`Fail:Zero, Fail:Zero | e})) -> Comp(a, {Fail{_}, `Fail:Zero|e})
    fun protect (m) () {
      handle (m()) {
          case <Fail => k> -> k (do `Fail)
      }
    }

    sig unprotect : (Comp(a, {`Fail:Zero, Fail:Zero | e})) -> Comp(a, {`Fail{_}, Fail:Zero|e})
    fun unprotect (m) () {
      handle (m()) {
          case <`Fail => k> -> k (do Fail)
      }
    }

    typename CNonLoc(a,e::Eff) = Comp(a, {Receive:Int, Fail:Zero, `Fail-    |e}) ;
    typename CLoc(a,e::Eff)    = Comp(a, {Receive:Int, Fail:Zero, `Fail:Zero|e}) ;

    sig protected_receives : ([Int]) -> (CNonLoc(a,{ |e})) -> Comp(Maybe(a), {Receive{_}, Fail:Zero, `Fail{_} |e})
    fun protected_receives (xs) (h) { unprotect ( maybe( receives ([xs]) ( protect ( h : CLoc(a,{ |e}) <- (CNonLoc(a,{ |e}))
    ) ) ) ) }

  }

  links> protected_receives ;
  protected_receives = fun : ([Int]) -> (Comp(a,{Receive:Int, Fail:Zero |e})) -> Comp(Maybe(a), {Receive{_}, Fail:Zero |e})

  links> solve_too_big( protected_receives ([21,21,21]) ( two ))) () ;
  (big = false, val = Just(Just(42))) : Sized (Maybe (Int))

  links> solve_too_big( protected_receives ([42,42,42]) ( two ))) () ;
  (big = true, val = Nothing) : Sized (Maybe (Int))
\end{lstlisting}

We can declare a protected version of !receives! that guaranties that other !Fail! effects will not interfere. When a ``too big'' number is encountered, the !Fail! effect raised can go through !protected_receives!, reach !solve_too_big!  and be correctly handled. The !big! field is set to !true!.

\paragraph{Remaining issues}
There is one issue remaining. The effect aliases being inlined before type-checking, we can get a label going out of scope. This will be identified by the typechecker and will raise a !local label ... is not bound error!. It seems that the effectname has escaped the scope.
\begin{lstlisting}
  fresh `A {
      effectname E = {`A:Int} ;
  }
  typename T = () -E-> () ;

  links>
  Type error: The local label `A<1> is not bound
  In expression: typename T = () -E-> ().
\end{lstlisting}
This is not really satisfying but should be fixed by improving effect aliases and giving them the same behaviour as type aliases. Furthermore, this could not cause code that should not type-check to type-check since it is catch.

\paragraph{Implementation}
All labels in the code can be either global or local, have a name and the local ones have a unique id. Labels with a backtick are parsed into free local label and normal label are parsed into global ones. During desugaring, a new pass binds the local labels. During type-checking, when a !fresh ... { ... }! binding is encountered, we add the labels into the context and typecheck each declaration in the scope. Before that, the context should be clean from any label that will be shadowed by the fresh declaration (labels that have the same name). When leaving the scope, we clean the context from the local labels to avoid them to escape the scope. Moreover we check during typechecking if types do not contain unbound or shadowed labels.

\begin{rem}
  For now all labels used in different parts of Links (effect rows but also records, variants, etc.) are represented internally with the same construction so all of them could support local labels. However the parser only accepts local labels in effect related things. If needed, allowing all labels to be local could be a way of improvement.
\end{rem}


\subsection{Polymorphic operations}
\label{sec:poly-op}

My last contribution was to implement the support for polymorphic operations in Links. Until then, only handlers could be polymorphic but not the operations themselves. However this could be useful in a lot of situations. For instance, when writing exceptions, one would want to have a polymorphic !Fail! operation so that it could be used in any location. Without actual polymorphism this could be simulated with a Zero type and its destructor as we have done in previous examples.

This is easily added since polymorphism is already incorporated in Links. The only thing to add is to allow operations to be of the form $\forall \alpha ::K. \dots$ and not only fat arrow types.

To make an operation polymorphic, the handler should be annotated with a polymorphic type. The type system cannot infer polymorphism and is not able to propagate the polymorphism information in the signature down to the effect cases. This is something that could be improved in the future.

\begin{lstlisting}[caption=Polymorphism example]
  sig catch : (() {Fail:forall a.a |e}~> b) {Fail{_} |e}~> Maybe(b)
  fun catch(m) {
    handle(m()) {
      case <Fail => k> : (forall a. () => a) -> Nothing
      case x -> Just(x)
    }
  }

  sig f : () {Fail:forall a.a}~> Int
  fun f () {
    if (do Fail)
      42
    else
      do Fail
  }

  catch (f)
  links> Nothing : Maybe (Int)
\end{lstlisting}



\section{Conclusion}
\label{sec:conclusion}

In this internship, I have discovered a new programming language, Links, and a new feature, effect handlers. I learnt how they work and I tried to make a contribution.

I have incorporated in Links useful and interesting features even if they are far from perfect and each of them could and will be improved in future versions of Links. For instance, type and effect aliases could be generalised and the kinding system might need some improvements for this. One may also want to go towards first class labels. I provided a way of creating new instances of labels but this could be extended. This still raises a huge amount of new issues. The way we achieve polymorphic operations is a bit constraining because the annotations have to be at the level of cases. Using some sort of bidirectionality, one may hope to avoid this and allow the programmer to only write polymorphic types in the signature of the handler for instance.

This internship allowed me to face many challenges related to code development such as working with a large codebase, understanding not-so-much-commented code and dealing with git. It is really satisfying to see that the code I wrote is now running and will be running in the official Links code.

In the end, I am really glad that I have been able to have this experience and that my work could be, at least a little, useful to research.

\paragraph{Acknowledgements}
\label{sec:acknowledgement}

I would like to thank the team that welcomed me in Edinburgh, that is of course Sam and Daniel my supervisors but also all the members of the PL group. I also would like to thank my fellow interns Nachi, Yi and Pierre and my flatmates Aleks, Iris and Misha that had to put up with me during these few months in Edinburgh.







\bibliographystyle{alpha}
\bibliography{biblio}
















\newpage

\appendix

\section*{Appendix}

\section{Artefact}
\label{sec:code-production}

The code that I have produced during this internship is available in my Links fork on GitHub \cite{gh:mylinks}. The notable branches are the master, the \texttt{fresh-label} branch that contains the work described in section \ref{sec:fresh-labels} and the \texttt{polymorphic-operations} branch that contains the work described in section \ref{sec:poly-op}.

The pull requests that I opened are available here \cite{gh:prs}.

The Links repository can be found at \cite{gh:links}. Set up and installation instructions are available on Links website \cite{links-org} or you can built in from source using the Makefile provided in the repository. After having installed the dependencies with !$ opam install --deps-only links!, a simple !$ make! should be sufficient.

To replicate the examples in this paper, use preferably the branches of my fork. The changes will be step by step included in Links and in new releases.

% TODO WHEN RELEASE !!
% TODO a branch with local + poly handlers

\section{Links technicalities}
\label{sec:tech}

Here are some technical points on Links syntax and semantics that could be useful to the reader.

\subsection{Comments}
\label{sec:comments}
Everything following a !#! in a line is a comment.

\subsection{Tuples}
\label{sec:tuples}
A tuple is a closed record with positive integer labels. For instance !(foo, bar)! is the same as !(1=foo, 2=bar)!.

Unit !()! is the empty record.


\subsection{Operation type}
\label{sec:operation-type}
An operation should always be of type !(a) => b! but one can write !Op:b! which will be desugared into !Op:() => b!.

A polymorphic operation type can also be sugared. One can write !Op:forall a. b! for !Op:forall a. () => b!. It is worth noting that this does \emph{not} stand for !Op:() => forall a. b!.

\subsection{Empty type}
\label{sec:tech:zero}
The empty variant type ![||]! is !Zero!. To destroy it, we use the following !absurd! function.
\begin{lstlisting}
  sig absurd : (Zero) -> a
  fun absurd(x) {
    switch ( x ) {}
  }
\end{lstlisting}

\subsection{Option type}
\label{sec:tech:maybe}
Links has a builtin polymorphic option type !Maybe! defined as below. An object of type !Maybe(a)! is either !Nothing! or !Just(x)! where !x! is of type !a!
\begin{lstlisting}
  typename Maybe(a) = [| Nothing  | Just : a |]
\end{lstlisting}

\subsection{Function types}
Function types are written !(a) {...}-> b!. The domain type is always embraced with parentheses. The braces contains an effect row that tells among others which effects can be performed by the function.

One can write !(a) -e-> b! when !e! is a row variable or an effect type and !(a) -> b! stands for !(a) -_-> b! : the function is then polymorphic in its effects.

!(a) {...}~> b!, !(a) ~e~> b! or !(a) ~> b! is a syntactic sugar that adds the special effect !wild:()! to the row. This is used to denote ``wild'' code, ie code that cannot be transformed into a SQL query. Recursion, IO or handlers are typically wild. See \citep{corelinks} for justifications and details on the use of row typing for database integration.

For more details on row typing, see section \ref{sec:row-typ}.

\subsection{Computation and handlers}
\label{sec:computation-handlers}
Links has a builtin type for computations
\begin{lstlisting}
  typename Comp(a, e::Row) = () ~e~> a
\end{lstlisting}

For better handler composability, we write handlers that take a computation and output another computation. Then we can compose them easily and we just need to launch the computation at the end :
\begin{lstlisting}
  # computation
  handler''( handler'( handler( f ) ) )
  # value
  handler''( handler'( handler( f ) ) ) ()
\end{lstlisting}

\section{Typing rules}
\label{sec:typing-rules}

We give extra typing rules for shallow and parameterised handlers.

\begin{prooftree}
  \AxiomC{$\Delta;\Gamma \vdash m : B / R'$}
  \AxiomC{$\Delta;\Gamma, x:B \vdash n : A / R$}
  \AxiomC{$R' = (l_{i} : B_{i} \To A_{i})_{i} ; R_{0}$}
  \AxiomC{$R = (l_{i} : P_{i})_{i} ; R_{0}$}
  \noLine
  \BinaryInfC{$\forall i,\; \Delta;\Gamma, p_{i}:B_{i}, r_{i}:A_{i} \to_{R'} A \vdash n_{i} : A / R$}
  \RightLabel{$ShallowHandle$}
  \TrinaryInfC{$\Delta;\Gamma \vdash shallowhandle (m) \{ case\ x \mapsto n\; (case \langle l_{i} (p_{i}) \To r_{i} \rangle \mapsto n_{i})_{i}\} : A / R$}
\end{prooftree}

\vspace{11pt}

\begin{prooftree}
  \AxiomC{$\Delta;\Gamma \vdash m : B / R'$}
  \AxiomC{$\Delta;\Gamma \vdash w : \gamma / R'$}
  \noLine
  \BinaryInfC{$\Delta;\Gamma, x:B, s:\gamma \vdash n : A / R$}
  \AxiomC{$R' = (l_{i} : B_{i} \To A_{i})_{i} ; R$}
  \AxiomC{$R = (l_{i} : P_{i})_{i} ; R_{0}$}
  \noLine
  \BinaryInfC{$\forall i,\; \Delta;\Gamma, s:\gamma, p_{i}:B_{i}, r_{i}:(A_{i},\gamma) \to_{R'} A \vdash n_{i} : A / R$}
  \RightLabel{$ParamHandle$}
  \BinaryInfC{$\Delta;\Gamma \vdash handle (m) (s \from w) \{ case\ x \mapsto n\; (case \langle l_{i} (p_{i}) \To r_{i} \rangle \mapsto n_{i})_{i}\} : A / R$}
\end{prooftree}

\section{Erasing procedure}
\label{sec:erasing-procedure}

We give the missing rules for the erasure procedure introduced in section \ref{sec:fresh-idea}.
\begin{table}[h!]
  \centering
  \begin{tabular}{cc}
    \AxiomC{$x = \alpha, P, \rho, \bullet$}
    \UnaryInfC{$x\uparrow_lx$}
    \DisplayProof
    &
      \AxiomC{$A\uparrow_{l}A'$}
      \AxiomC{$B\uparrow_{l}B'$}
      \AxiomC{$R\uparrow_{l}R'$}
      \TrinaryInfC{$A \to_{R} B \uparrow_{l} A' \to_{R'} B'$}
      \DisplayProof
  \end{tabular}
\end{table}
\begin{table}[h!]
  \centering
  \begin{tabular}{ccc}
    \AxiomC{$A\uparrow_{l}A'$}
    \AxiomC{$B\uparrow_{l}B'$}
    \BinaryInfC{$A \To B \uparrow_{l} A' \To B'$}
    \DisplayProof
    &
      \AxiomC{$A\uparrow_{l}A'$}
      \AxiomC{$B\uparrow_{l}B'$}
      \BinaryInfC{$A\ B \uparrow_{l} A'\ B'$}
      \DisplayProof
    &
      \AxiomC{$T\uparrow_{l}T'$}
      \UnaryInfC{$\forall \alpha::K.T\uparrow_{l}\forall\alpha::K.T'$}
      \DisplayProof
  \end{tabular}
\end{table}


\begin{table}[h!]
  \centering
  \begin{tabular}{ccc}
      \AxiomC{$A\downarrow_{l}$}
      \UnaryInfC{$A \to_{R} B \downarrow_{l}$}
      \DisplayProof
    &
      \AxiomC{$B\downarrow_{l}$}
      \UnaryInfC{$A \to_{R} B \downarrow_{l}$}
      \DisplayProof
    &
      \AxiomC{$R\downarrow_{l}$}
      \UnaryInfC{$A \to_{R} B \downarrow_{l}$}
      \DisplayProof
  \end{tabular}
\end{table}

\begin{table}[h!]
  \centering
  \begin{tabular}{ccccc}
      \AxiomC{$A\downarrow_{l}$}
      \UnaryInfC{$A \To B \downarrow_{l}$}
      \DisplayProof
    &
      \AxiomC{$B\downarrow_{l}$}
      \UnaryInfC{$A \To B \downarrow_{l}$}
      \DisplayProof
    &
      \AxiomC{$A\downarrow_{l}$}
      \UnaryInfC{$A\ B \downarrow_{l}$}
      \DisplayProof
    &
      \AxiomC{$B\downarrow_{l}$}
      \UnaryInfC{$A\ B \downarrow_{l}$}
      \DisplayProof
    &
      \AxiomC{$T\downarrow_{l}$}
      \UnaryInfC{$\forall \alpha::K.T\downarrow_{l}$}
      \DisplayProof
  \end{tabular}
\end{table}

\end{document}
