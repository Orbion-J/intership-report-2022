\documentclass[11pt, nonacm=true, language=french, language=english]{acmart}

\input{./preambule/preambule.tex}
\usepackage{listings}

\usepackage{letltxmacro}
\newcommand*{\SavedLstInline}{}
\LetLtxMacro\SavedLstInline\lstinline
\DeclareRobustCommand*{\lstinline}{%
  \ifmmode
    \let\SavedBGroup\bgroup
    \def\bgroup{%
      \let\bgroup\SavedBGroup
      \hbox\bgroup
    }%
  \fi
  \SavedLstInline
}

\lstdefinelanguage{links}{
  morekeywords={sig,fun,case,switch,if,else,typename,effectname,do,handle,shallowhandle,var,fresh},
  morecomment=[l]{\#},
  commentstyle=\color{gray}
}
\lstset{
  basicstyle=\ttfamily\footnotesize,
  captionpos=b,
  numberstyle=\tiny\color{gray},
  numbers=left,
  breaklines
}
\lstset{language=links}
\lstMakeShortInline!

\setcopyright{none}

\author[R. Jourde]{Robin Jourde}
\affiliation{%
  \institution{École Normale Supérieure de Lyon}%
  \country{France}%
}
\email{Robin.Jourde@ens-lyon.fr}
\author{Supervised by Sam Lindley}
\email{Sam.Lindley@ed.ac.uk}
\author{Daniel Hillerström}
\email{Daniel.Hillerstrom@ed.ac.uk}
\affiliation{%
  \institution{The University of Edinburgh}%
  \country{United Kingdom}%
}

\renewcommand\shortauthors{Robin Jourde}


\title[M1 Intership Report]{M1 Internship Report : Effect Typing for Links}
\subtitle{2 May 2022 -- 22 July 2022, The University of Edinburgh}

\date{2 May 2022 -- 22 July 2022}

\begin{document}


\begin{abstract}
  This paper is the report of my internship at the School of Informatics of the University of Edinburgh with Sam Lindley and Daniel Hillerström from 2 May 2022 to 22 July 2022.
  Effect handlers are a language feature that is becoming more and more widespread. They allow the user to define and compose many functionalities from exceptions to concurrency and probabilistic programming.
  Links is an experimental tierless functional language for the web, mainly developed in the University of Edinburgh. Among its numerous features, Links supports effect handlers.
  The goal of my intership was to improve the effect typing system of Links, allowing aliases, avoiding pollution and allowing polymorphic operations.
\end{abstract}


\maketitle

\tableofcontents


\section{Introduction}

\section{Links}

\begin{fquote}[Links website (\url{https://links-lang.org/})]
 Links is a functional programming language designed to make web programming easier.
\end{fquote}

Links \cite{} is a tierless functional programming language for the web developed at the University of Edinburgh. Typical web development involves the manipulation of several \emph{tiers} which means several, sometimes really different, programming languages :
\begin{itemize}
  \item the server side written in Python or Java for instance
  \item the client side in JavaScript and HTML/CSS
  \item the database queries in SQL
\end{itemize}
This is neither elegant nor really practical and prevents easy binding between different parts of the program that need to communicate data. It can cause \emph{impedance mismatch}, ie situations where the objects required by the server do not match what the database provide and vice versa.

Links avoids these by providing the programmer one single language for each tier (HTML/CSS are still needed) that is compiled into bytecode for the server, JavaScript for the client and SQL for the queries.

Links also supports numerous useful features including
\begin{itemize}
  \item polymorphic variants
  \item regular expressions
  \item session types
  \item row typing
  \item effect handlers (see \ref{sec:handlers})
\end{itemize}
It is used as an experimental language by researchers to try out new ideas and what could be future widespread programming languages features.

Links is strict, statically typed and use a Hindley-Milner type system as well as a Rémy style row typing system \ref{sec:row-typ} \cite{}. Its syntax is inspired from JavaScript and ML. Its compiler \cite{} is written in OCaml.

\begin{rem}
  In appendix \ref{sec:tech}, the reader could find some technical points on Links syntax and semantics that are not worth it to develop here. He is invited to look at it whenever needed.
\end{rem}

\section{Effect handlers}
\label{sec:handlers}

In functional programming, functions are seen as black boxes that takes an input and computes an output. Though this view of \emph{pure} functions is convenient and pleases $\lambda$-calculus fans, it fails to accurately represent what real programming is. Computations interact with the outer world by many means :
\begin{itemize}
  \item input/output
  \item concurrency
  \item exceptions
  \item choice and non determinism
  \item ...
\end{itemize}
The ``outer world'' here stand for anything that is not the pure computation, from memory, other threads and user interaction to the evaluation context itself.
These interactions not taken into account by the black-box model are called \emph{effects}.

Gordon Plotkin and Matija Pretnar \cite{} introduced a construct that allow \emph{composable} and \emph{customisable} user-defined interpretation of effects : \emph{effect handlers}. They give the programmer direct access to the context, in the form of a first class continuation, often called \emph{resumption}.

Effect handlers can be seen as a generalisation of exception handlers. One can perform an effect in the same way as one could raise an exception and this will transfer the flow control to a handler. It is given the delimited continuation between the point where the effect is performed and where it is handled and can use it
\begin{description}
  \item[0 times] and act as an exception handler
  \item[once] (linear handler)
  \item[twice or more] (non-linear handler) to simulate a choice for instance
\end{description}

Effect handlers are being shown a growing industrial interest nowadays. Below are listed some of the biggest projects that uses and implement some kind of effect handlers
\begin{itemize}
  \item GitHub code analysis library Semantic (used in more than 25 million repositories)
  \item Meta JavaScript UI library React (used in mire than 2 million websites)
  \item Uber Pyro language
  \item WebAssembly
\end{itemize}

\subsection{Syntax and usage}

We give the Links syntax alongside with usage of effect handlers and operations. All examples in this report are written in Links.

Inside any segment of code, one can invoke an operation !Op! with payload !p! writing !do Op(p)!. This has to be scoped into a handler of this operation. It will take the payload and the resumption and decide what to do.

\begin{lstlisting}[caption=Handler,label=lst:handler]
  handle ( code ) {
    case <Op(p) => r> -> ...
    case x -> ...
  }
\end{lstlisting}

Listing \ref{lst:handler} give the syntax for a handler for !Op!, !code! being the code that can perform the operation. When the operation is invoked, the right hand side of line 2 is executed with !p! the payload and !r! the resumption bound in context. When !code! returns a value, line 3 is executed with !x! bound to that value.

If the handler gives the resumption a value !v!, it acts as if !do Op(p)! returned the value !v!. If the payload has type !t! and !v! has type !t'!, we say that !Op! has type !t => t'!.

The type system keeps track of what effects can be performed. A function from type !a! to !b! which can performs operations !Op1: t1 => t1'!, \dots, !Opk:tk => tk'! will have type !(a) {Op1:t1 => t1', ..., Opk:tk => tk'}-> b!.


\subsection{Examples}

\subsubsection{A first exception handler}
\label{sec:first-except-handl}

~

\begin{lstlisting}[caption=Fail invocation]
  sig assert_positive : (Int) {Fail:() => Zero|_}-> Int
  fun assert_positive(x) {
    if (x>0) x else absurd(do Fail)
  }
\end{lstlisting}

This first example shows a function !assert_positive! that takes an integer and returns it only if it positive, else, it raises the effect !Fail! (for details on !absurd! and the !Zero! type, see \ref{sec:tech:zero}). This is the simplest example when one operation is invoked with no payload.

\begin{lstlisting}[caption=maybe handler, label=lst:mb-h]
  sig maybe : (() {Fail:() => Zero|e}~> a) -> () {Fail{_}|e}~> Maybe(a)
  fun maybe(m) () {
    handle(m()) {
      case <Fail> -> Nothing
      case x -> Just(x)
    }
  }
\end{lstlisting}

This operation can be handled by handler \ref{lst:mb-h}. This is actually an exception handler since the resumption is not used in the right hand side (and thus can be omitted in the left hand side). The \emph{effect signature} is !{Fail: () => Zero}!, that means there is only one operation called !Fail! that will be handled.

When the operation !Fail! is invoked, the handler directly returns a value, here !Nothing!. When the computation returns a value, the handler will return that value, embedded in the !Maybe! type (on !Maybe! type, see \ref{sec:tech:maybe}).

The function !maybe! will take a computation that can perform the effect !{Fail: () => Zero|e}! ie the operation !Fail! and possibly other effects, captured by the row variable !e!, and returns something of type !a!. It will execute this computation, performing effects from !e! that should be handled by another handler at some point. In the end, it returns a value of type !Maybe(a)!.

The !Fail{_}! in the effect row indicates a polymorphic presence for the operation. Roughly it means that the operation can or cannot be present after. This is needed since the effect type system enforces that all operations in a row are distinct. !Fail! cannot belong to !e! because of the effect row of the input computation.

\begin{lstlisting}
  sig h2g2 : () {Fail:() => Zero|_}-> Int
  fun h2g2 () {
    assert_positive( -6 * -7 )
  }
  sig h2g2' : () {Fail:() => Zero|_}-> Int
  fun h2g2' () {
    assert_positive( -6 ) * -7
  }
\end{lstlisting}

We can then use the !maybe! function to handle the failures in functions !h2g2! and !h2g2'! :

\begin{lstlisting}[caption=Links console]
  links> maybe ( h2g2 ) () ;
  Just(42) : Maybe (Int)
  links> maybe ( h2g2' ) () ;
  Nothing : Maybe (Int)
\end{lstlisting}


\subsubsection{Drunk coin tossing}

We consider now a new operation !Choose! that can produce a boolean and use it to simulate a drunk coin toss. The drunk tosses the coin and either let it fall or catch it and see heads or tail.

\begin{lstlisting}[caption=Drunk toss]
  typename Toss = [| Heads | Tail |] ;

  sig toss : () {Choose:Bool|_}-> Toss
  fun toss () {
    if (do Choose) Heads else Tail
  }

  sig drunkToss : () {Choose:Bool, Fail:Zero|_}-> Toss
  fun drunkToss () {
    if (do Choose)
      # catch
      toss ()
    else
      # fall
      absurd(do Fail)
  }

  sig drunkTosses : (Int) -> Comp([Toss], {Choose:Bool, Fail:Zero|_})
  fun drunkTosses (n) () {
    if (n<=0)
      []
    else
      drunkToss() :: drunkTosses (n-1) ()
  }
\end{lstlisting}

We can define several handlers for this operation.

\begin{lstlisting}[caption=Toss handlers]
  # linear handler : always true
  sig h_true : (Comp(a,{Choose:Bool|e})) -> Comp(a,{Choose{_}|e})
  fun h_true (m) () {
    handle (m()) {
        case <Choose => r> -> r(true)
    }
  }

  # non-linear handler : all choices in a list
  sig h_all : (Comp(a,{Choose:Bool|e})) -> Comp([a],{Choose{_}|e})
  fun h_all (m) () {
    handle (m()) {
        case <Choose => r> -> r(true) ++ r(false)
        case x -> [x]
    }
  }
\end{lstlisting}

And then we can compose the different handlers in several ways.

\begin{lstlisting}
  links> maybe ( h_true ( drunkTosses(2) ) ) () ;
  Just([Heads, Heads]) : Maybe ([Toss])
  links> h_true ( maybe ( drunkTosses(2) ) ) () ;
  Just([Heads, Heads]) : Maybe ([Toss])

  links> maybe ( h_all ( drunkTosses(2) ) ) () ;
  Nothing : Maybe ([[Toss]])
  links> h_all ( maybe ( drunkTosses(2) ) ) () ;
  [Just([Heads, Heads]), Just([Heads, Tail]), Nothing, Just([Tail, Heads]), Just([Tail, Tail]), Nothing, Nothing] : [Maybe ([Toss])]
\end{lstlisting}

We try different combinations for 2 coin tosses. In the two first cases, there is no failure so the order of handlers won't matter. The coin is always catch and always on heads.

In the third case, !h_all! imposes that all possibilities are explored so at some point, the coin will fall. This causes a failure, catch by !maybe! that simply returns !Nothing!.

The last case is the most complicated one. The failures are catch by !maybe! \emph{under} !h_all!. That means !h_all! won't see failures and will take each result, whether it is a !Nothing! or a list of heads/tail and form its big list of all possibilities.


\subsection{Semantics}
\label{sec:semantics}

We give the operational semantics for handlers.
\[
  \begin{array}{rcll}
    !handle ( !v! ) { !H! }! & \longrightarrow & N[v/!x!] \\
    !handle ( !\mathcal E[!do !Op_{i}!( !v! )!]! ) { !H! }! & \longrightarrow & N_{i}[v/!p!, !fun (x)  { handle ( !\mathcal E[!x!] ! ) { !H! } }!/!r!] & Op_{i} \notin \mathcal E\\
  \end{array}
\]

where $H =
\left\{\begin{array}{l}
  !case x! \mapsto N \\
  !case ! \langle Op_{i}(!p!) \To !r!\rangle \mapsto N_{i} \\
  \dots \\
\end{array}\right.$

and $\mathcal E$ is an evaluation context : $\mathcal E ::= [] \mid !handle ( !\mathcal E! ) { !H! } ! \mid !var x = ! \mathcal E ! ; ! N$.

$Op \in \mathcal E$ means there is a handler for $Op$ in $\mathcal E$.

If there is a value $v$ inside the handler, we call the return case $N$ with !x! bound to $v$. When the handler is the most inner one that can handle the operation $Op_{i}$ invoke with some payload $v$, what is insured by $Op_{i}\notin \mathcal E$, we bind the payload and build the resumption before calling the case $N_{i}$.

The resumption is embedded in the current handler since operation $Op_{i}$ could be invoked in the rest of the evaluation context $\mathcal E$. This is called a \emph{deep} handler.

\paragraph{Shallow handlers}
Links also support \emph{shallow} handlers, ie handlers that do not automatically reuse the handler in the resumption. The programmer has to write it and can choose another handler if needed. Below is the new rule for shallow handler.
\[
  \begin{array}{rcll}
    !shallowhandle ( !\mathcal E[!do !Op_{i}!( !v! )!]! ) { !H! }! & \longrightarrow & N_{i}[v/!p!, !fun (x)  { ! E[!x!] ! }!/!r!] & Op_{i} \notin \mathcal E\\
  \end{array}
\]

\paragraph{Parameterised handlers}

Another useful feature of handlers is that they could be parameterised. The programmer can give the handler a parameter that is carried along the computation.

\begin{lstlisting}[caption=Example of parameterised handler]
  sig h_state : (a) -> (Comp(b,{ Get:()=>a, Put:(a)=>() | e })) ~> Comp((b,a), { Get{_}, Put{_} | e })
  fun h_state (init) (m) () {
    handle (m()) (s <- init) {
      case x -> (x, s)
      case <Get => r> -> r (s, s)
      case <Put(s') => r> -> r ((), s')
    }
  }
\end{lstlisting}

\begin{lstlisting}
  fun ex () {
    var x = do Get * 10 ;
    var x = 2*x + do Get ;
    do Put(x) ;
    ()
  }

  links> h_state (2) (ex) () ;
  ((), 42) : ((), Int)
\end{lstlisting}

A second parameter is given to the !handle! construct that binds a variable and the resumption will take an additional parameter.

In the example above, we use that feature to write a state-cell handler. There are two operations !Put! and !Get! that respectively write into the cell and read what is inside. The parameter here is just the content of the cell.

Here are the reduction rules for parameterised handlers
\[
  \begin{array}{rcll}
    !handle ( !v! ) ( s!\from w! ) { !H! }! & \longrightarrow & N[v/!x!, w/!s!] \\
    !handle ( !\mathcal E[!do !Op_{i}!( !v! )!]! ) ( s!\from w! ) { !H! }! & \longrightarrow & N_{i}[v/!p!, w/!s!, !fun (x, s')  { handle ( !\mathcal E[!x!] ! ) ( s!\from!s' ) { !H! } }!/!r!] \\
    &&Op_{i} \notin \mathcal E\\
  \end{array}
\]

\begin{rem}
  A parameterised has to be deep since the parameter needs a handler to carry it.
\end{rem}

\paragraph{Relationships between handlers}

Those three kinds of handlers are equivalent in the sense that it is possible to express each of them using one other.

If it is easy to see how to express a deep handler from a parameterised handler or from a shallow handler, the converse is not so obvious. See \cite{}.

\section{Typing}

Links is a strongly statically typed language. In this section, we describe some main features of Links type system that allow us to type effect handlers.

\subsection{Row Typing}
\label{sec:row-typ}

In order to type effects, we store in function types the effects that are \emph{allowed} to be perform during the execution of that function. To do so we use rows. They are an unordered and labeled data and type structure. They are also used in others features of Links as records and variants.

In the most general setting, a row is defined by
\[
  \rho ::= \cdot \mid rv \mid l:\alpha;\rho
\]
where $rv$ is a row variable, $l$ is a label and $\alpha$ is a data. $\cdot$ denotes the empty row.

A row is said to be \emph{open} if it ends with a row variable and \emph{closed} if it ends with the empty row.

For actual records, the data are actual values of the language but in the typing setting (typing effects, records and variants), $\alpha$ will be a type.

We require also that in one row, labels are all distinct and we consider row equal up to reordering of pairs labels/data.

\begin{ex}
  $Fail:Zero; Choose:Bool; \cdot$ is a valid row and is equal to $Choose:Bool; Fail:Zero; \cdot$ but $Fail:Zero; Fail:Int; e$ and $Fail:Zero; Fail:Zero; e$ are not valid. In the open row $Choose:Bool; e$, $e$ could not be substituted by anything with label $Choose$.
\end{ex}

\paragraph{Links syntax}
In Links, we write effect rows between braces !{ ... }!. The empty row is denoted by !{}!, the closed row $l_{1}:\alpha_{1}; \dots; l_{k}:\alpha_{k}$ is denoted by !{l1:a1, ..., lk:ak}! and the open row $l_{1}:\alpha_{1}; \dots; l_{k}:\alpha_{k}; e$ is denoted by !{l1:a1, ..., lk:ak | e}!.


\subsection{Links Type System}
\label{sec:links-typ}

We describe in this section Links type system. In order to avoid useless complexity, we focus on the parts of the type system that are useful to understand effect typing. We omit easy and common parts as well as part used only for other Links features.
\begin{align*}
  \tau ::=\ & P & \text{primitive types} \\
  \mid\ & \tau \to_{\rho} \tau & \text{function type} \\
  \mid\ & \tau \To \tau & \text{operation type} \\
  \mid\ & (\rho) & \text{record type} \\
  \mid\ & [\rho] & \text{variant type}
\end{align*}

\begin{rem}
  A tuple is a closed record with positive integer labels : $(foo, bar) = (1:foo; 2:bar; \cdot)$. Unit $()$ is the empty record $(\cdot)$. $Zero$ is the empty variant $[\cdot]$.
\end{rem}


The typing judgment has to take into account the current allowed effects. We gather them into a row $\rho$ and we write $\Gamma \vdash e : \tau / \rho$ for expression $e$ has type $\tau$ in context $\Gamma$ and can perform effects in $\rho$.

We give below the main typing rules that allow to understand how effect handlers should be typed. The other rules are the obvious ones and can be found in appendix \ref{sec:typing-rules}. For the sake of clarity, shallow and parameterised handlers rules have also been moved to the appendix.

\begin{prooftree}
  \AxiomC{$\Gamma \vdash p : \beta / \rho$}
  \AxiomC{$\rho = Op : \beta \To \alpha ; \rho'$}
  \RightLabel{$Op$}
  \BinaryInfC{$\Gamma \vdash do\ Op(p) : \alpha / \rho$}
\end{prooftree}

\begin{prooftree}
  \AxiomC{$\Gamma \vdash f : \beta \to_{\rho} \alpha / \rho$}
  \AxiomC{$\Gamma \vdash t : \beta / \rho$}
  \RightLabel{$App$}
  \BinaryInfC{$\Gamma \vdash f t : \alpha / \rho$}
\end{prooftree}

\begin{prooftree}
  \AxiomC{$\Gamma, x:\beta \vdash e : \alpha / \rho$}
  \RightLabel{$Fun$}
  \UnaryInfC{$\Gamma \vdash fun (x) \{ e \} : \beta \to_{\rho} \alpha / \rho$}
\end{prooftree}

\begin{prooftree}
  \AxiomC{$\Gamma \vdash m : \beta / \rho'$}
  \AxiomC{$\Gamma, x:\beta \vdash n : \alpha / \rho$}
  \AxiomC{$\Gamma, p_{i}:\beta_{i}, r_{i}:\alpha_{i} \to_{\rho} \alpha \vdash n_{i} : \alpha / \rho$}
  \AxiomC{$\rho' = Op_{i} : \beta_{i} \To \alpha_{i} ; \rho$}
  \RightLabel{$Handle$}
  \QuaternaryInfC{$\Gamma \vdash handle (m) \{ case\ x \mapsto n\ case \langle Op_{i} (p_{i}) \To r_{i} \rangle \mapsto n_{i}\} : \alpha / \rho$}
\end{prooftree}


\begin{prooftree}
  \AxiomC{$\Gamma \vdash e : \alpha / \rho$}
  \AxiomC{$\rho \subset \rho'$}
  \RightLabel{$WeakEff$}
  \BinaryInfC{$\Gamma \vdash e : \alpha / \rho'$}
\end{prooftree}

where $\rho \subset \rho'$ means that $\rho$ is open and for all $l:\alpha$ in $\rho$, $l:\alpha$ also appears in $\rho'$.


Rule $Op$ states that invoking an operation requires a ambient effect row that contains it with the correct types. Rule $App$ ensure that, when applying a function, its effect row is compatible with the ambient one. The $Handle$ rule types a !handle! construct. The important thing to notice is that the row used to type $m$ obviously contains the operations $Op_{i}$ handled and that after handling, all $Op_{i}$s have been removed from the row. The last rule mentioned here ensures that the ambient effect row mentions effects that are \emph{allowed} to be performed but not necessary since an effect can be added to the row.

We say that an expression $e$ type-checks only if no unhandled effects are allowed : $\Gamma \vdash e : \alpha / \cdot$, noted $\Gamma \vdash e : \alpha$.


\begin{thm}
  If $\Gamma \vdash e : \alpha / \rho$, in the execution of $e$ only effects in $\rho$ are performed and not handled.
\end{thm}
\begin{cor}
  If $\Gamma \vdash e : \alpha$, in the execution of $e$ all effects are handled.
\end{cor}

See \cite{} for the proof.


\subsection{Bidirectional Typing}

\subsection{Polymorphism}


\section{Contributions}

During my internship I added some new features to Links that have been merged into the 0.0.0 release.

\subsection{Effect Aliases}

In Links we can define type aliases using the keyword !typename!.
\begin{lstlisting}[caption=Type alias examples]
  # sum type via variants
  typename BinTree(a) = [| Node(BinTree(a), a, BinTree(a)) | Leaf |] ;
  # product type
  typename IntPair = (Int, Int) ;
  # record type
  typename Pet = (name:String, age:Int, species:String, Fur:Bool) ;
  # function
  typename Comp(a, e::Row) = () ~e~> a ;
\end{lstlisting}

But until now, there was no way to define such thing for effects. This is really usefull since when working with effects, the same set of effects show up everywhere.

Using the new keyword !effectname! we can now write an alias for an effect row :
\begin{lstlisting}
  effectname MyEffectRow(a, ... ,e::Eff, ...) = { Op1 : type, ... | e } ; # open row
  effectname MyEffectRow(a, ... ) = { Op1 : type, ... } ; # closed row
\end{lstlisting}

To use it in a signature or in another type or effect alias just apply it with the right arguments as for typename things. In arrows, it can be used as row variables:
\begin{lstlisting}
  () -MyEffectRow(args)-> ()
\end{lstlisting}

However, due to lack of kind inference, row variables and aliases have to be used carefully so that Links does not think they are of kind type. We need to write them most of the time between braces !{ | ... }!. For instance, if there is !effectname E(a::Eff) = {X : ... | a }! and a row variable !e::Eff!, you will have to write !E({ |e})!, and similarly for another effect alias instead of the variable. This makes the usage of several nested aliases a bit messy, it would be nice if it could be avoided.

Recursive effect aliases are not available for now. The aliases are replaced by the row they correspond to, aliases are not kept are not printed out.

The implementation is mostly inspired by what is done for type aliases.

\subsection{Fresh Labels}
\label{sec:fresh-labels}

\subsubsection{The pollution problem}
\label{sec:pollution-problem}

We first introduce a problem that arises when playing with numerous effects and that we will be calling \emph{effect pollution}. Let us start with an example.

\begin{lstlisting}
  sig safe_sqrt : ( Comp(a, {Fail:Zero, Sqrt:(Float)=>Float| e}) ) -> Comp(a , {Fail:Zero, Sqrt{_} | e})
  fun safe_sqrt (m) () {
    handle (m())  {
        case <Sqrt(x) => r> -> r (if (x<0.0) absurd(do Fail) else sqrt(x))
        case x -> x
    }
  }

  sig maybe_sqrt : ( Comp(a, {Fail:Zero, Sqrt:(Float)=>Float| e}) ) -> Comp(Maybe(a) , {Fail{_}, Sqrt{_} | e})
  fun maybe_sqrt (m) {
    maybe ( safe_sqrt( m ) )
  }
\end{lstlisting}

Let !safe_sqrt! be a handler for the operation !Sqrt! that takes a float and computes its square root. If the number is negative, the handler raises a failure via the !Fail! operation. Let !maybe_sqrt! the composition of the !maybe! handler for failures seen previously and the !safe_sqrt! handler.
\begin{lstlisting}
  fun shrink (x) {
    var y = do Sqrt(x) ;
    if (y < x)
      y
    else
      absurd(do Fail)
  }

  fun end (m) () {
    handle (m()) {
      case x -> [x]
      case <Fail> -> []
    }
  }

  fun f () {
    end ( maybe_sqrt ( fun () { shrink(1.2) +. shrink(0.3) } ) ) ()
  }

  links> f () ;
  [Nothing] : [Maybe(Float)]
\end{lstlisting}

Let us image that another piece of code describe above uses this !Sqrt! feature to compute its square roots. The function !shrink! takes the square root and then checks whether the number has shrunk. If it is not the case, it raises an exception catch by the handler !end!. What could happen there is that the !Fail! exception used for !Sqrt! can collided with the !Fail! exception used by this piece of code. That is what happen in function !f! : this should have given a empty list since all square roots are correct and one value is not shrunk but the !Fail! from the !shrink! is catch by !maybe_sqrt! that returns !Nothing!.

That kind of effect pollution could become really annoying when one works with a large amount of code and it reduces modularity.

\subsubsection{State of the art}
\label{sec:state-art}

  TODO

\subsubsection{A fresh idea ?}
\label{sec:fresh-idea}

  TODO

\subsubsection{Implementation and usage in Links}
\label{sec:impl-usage-links}

I added the possibility to define local labels, ie labels that can only be used in a specific scope.

The user can define one or more local labels that will be bound in the scope with
\begin{lstlisting}
  fresh `A, `B {
    [ scope where labels `A and `B are bound ]
  }
\end{lstlisting}

He can use the local labels so defined in the scope as any other effect label but he cannot use them outside that scope.

\paragraph{Going out of scope} TODO
A function, a value or a type alias that has such a label in its type cannot escape the scope. When we leave the scope, we try to erase the label from the type and if it is possible (ie if the label as a polymorphic or absent presence) the function/value is available in the rest of the program, it's type being cleaned from any local label. Otherwise, the function/value/typename is removed from the context and trying to use it will cause an unknown variable or Unbound type constructor error.

\paragraph{Remaining issues}
There is one issue remaining. The effect aliases being inlined before type-checking, we can get a label going out of scope. This will be identified by the typechecker and will raise a !local label ... is not bound error!. It seems that the effectname has escaped the scope.
\begin{lstlisting}
  fresh `A {
      effectname E = {`A:Int} ;
  }
  typename T = () -E-> () ;

  links>
  Type error: The local label `A<1> is not bound
  In expression: typename T = () -E-> ().
\end{lstlisting}
This is not really satisfying but should be fixed by improving effect aliases and giving them the same behavior as type aliases. Furthermore, this could not cause code that should not type-check to type-check since it is catch.

\paragraph{Implementation}
Briefly, here is how the code works. All labels in the code can be either global or local, have a name and the local ones have a unique id. Labels with a backtick are parsed into free local label and normal label are parsed into global ones. During desugaring, a newpass binds the local labels. During type-checking, when a !fresh ... { ... }! binding is encountered, we add the labels into the context and typecheck each declaration in the scope. Before that, the context should be clean from any label that will be shadowed by the fresh declaration (labels that have the same name). When leaving the scope, we clean the context from the local labels to avoid them to escape the scope. Moreover we check during typechecking if types do not contain unbound or shadowed labels.

\begin{rem}
  For now if all labels are internally of the same type and then can be local or global, the parser only accepts local labels in effect related things. If needed, this could be a way of improvement.
\end{rem}


\subsection{Polymorphic Operations}

















\bibliographystyle{alpha}
\bibliography{biblio.bib}

















\appendix

\section{Links technicalities}
\label{sec:tech}

Here are some technical points on Links syntax and semantics

\subsection{Comments}
\label{sec:comments}
Everything following a !#! in a line is a comment.

\subsection{Operation type}
\label{sec:operation-type}
An operation should always be of type !(a) => b! but one can write !Op:b! which will be desugared into !Op:() => b!.

\subsection{Empty type}
\label{sec:tech:zero}
The empty type is !Zero!. To destroy it, we use the following !absurd! function.
\begin{lstlisting}
  sig absurd : (Zero) -> a
  fun absurd(x) {
    switch ( x ) {}
  }
\end{lstlisting}

\subsection{Option type}
\label{sec:tech:maybe}
Links has a builtin polymorphic option type !Maybe! defined as below. An object of type !Maybe(a)! is either !Nothing! or !Just(x)! where !x! is of type !a!
\begin{lstlisting}
  typename Maybe(a) = [| Nothing  | Just : a |]
\end{lstlisting}

\subsection{Function types}
Function types are written !(a) {...}-> b!. The domain type is always embraced with parentheses. The braces contains an effect row that tells among others which effects can be performed by the function.

One can write !(a) -e-> b! when !e! is a row variable or an effect type and !(a) -> b! stands for !(a) -_-> b! : the function is then polymorphic in its effects.

!(a) {...}~> b!, !(a) ~e~> b! or !(a) ~> b! is a syntactic sugar that adds the special effect !wild:()! to the row. This is used to denote ``wild'' code, ie code that cannot be transformed into a SQL query. Recursion, IO or handlers are typically wild. \cite{}

For more details on row typing, see section \ref{sec:row-typ}.

\subsection{Computation and handlers}
\label{sec:computation-handlers}
Links has a builtin type for computations
\begin{lstlisting}
  typename Comp(a, e::Row) = () ~e~> a
\end{lstlisting}

For better handler composability, we write handlers that take a computation and output another computation. Then we can compose them easily and we just need to launch the computation at the end :
\begin{lstlisting}
  # computation
  handler''( handler'( handler( f ) ) )
  # value
  handler''( handler'( handler( f ) ) ) ()
\end{lstlisting}

\section{Typing Rules}
\label{sec:typing-rules}

\begin{prooftree}
  \AxiomC{$\Gamma \vdash m : \beta / \rho'$}
  \AxiomC{$\Gamma, x:\beta \vdash n : \alpha / \rho$}
  \AxiomC{$\rho' = Op_{i} : \beta_{i} \To \alpha_{i} ; \rho$}
  \noLine
  \UnaryInfC{$\Gamma, p_{i}:\beta_{i}, r_{i}:\alpha_{i} \to_{\rho'} \alpha \vdash n_{i} : \alpha / \rho$}
  \RightLabel{$ShallowHandle$}
  \TrinaryInfC{$\Gamma \vdash shallowhandle (m) \{ case\ x \mapsto n\ case \langle Op_{i} (p_{i}) \To r_{i} \rangle \mapsto n_{i}\} : \alpha / \rho$}
\end{prooftree}

\vspace{11pt}

\begin{prooftree}
  \AxiomC{$\Gamma \vdash m : \beta / \rho'$}
  \AxiomC{$\Gamma \vdash w : \gamma / \rho'$}
  \noLine
  \BinaryInfC{$\Gamma, x:\beta, s:\gamma \vdash n : \alpha / \rho$}
  \AxiomC{$\rho' = Op_{i} : \beta_{i} \To \alpha_{i} ; \rho$}
  \noLine
  \UnaryInfC{$\Gamma, s:\gamma, p_{i}:\beta_{i}, r_{i}:(\alpha_{i},\gamma) \to_{\rho'} \alpha \vdash n_{i} : \alpha / \rho$}
  \RightLabel{$ParamHandle$}
  \BinaryInfC{$\Gamma \vdash handle (m) (s \from w) \{ case\ x \mapsto n\ case \langle Op_{i} (p_{i}) \To r_{i} \rangle \mapsto n_{i}\} : \alpha / \rho$}
\end{prooftree}

\end{document}
